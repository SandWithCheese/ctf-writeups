const express = require("express")
const app = express()
const http = require("http").createServer(app)
const sqlite3 = require("sqlite3").verbose()
const db = new sqlite3.Database("scores.db")
const io = require("socket.io")(http, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"],
    credentials: true,
    transports: ["websocket", "polling"],
  },
  allowEIO3: true,
})
const port = process.env.PORT || 3000

db.serialize(() => {
  db.run(
    "CREATE TABLE IF NOT EXISTS scores (uuid TEXT PRIMARY KEY, name VARCHAR(255), score INTEGER)"
  )
})

let clients = []

const NETCOMP_FLAG = "Netcomp{flag_asli_ada_badaknya_untuk_orang_karbit}"
const MINIMUM_SCORE_FOR_FLAG = 5000
const MAX_ALLOWED_SCORE_PER_TICK = 50
const SERVER_TICK = 900

function deleteData(socket) {
  db.run("DELETE FROM scores WHERE uuid = ?", [socket.uuid], function (err) {
    socket.disconnect()
  })
}

io.on("connection", async (socket) => {
  let clientIndex = clients.indexOf(socket)
  if (clientIndex != -1) {
    clients[clientIndex] = socket
  } else {
    let currentTimestamp = Date.now()
    socket.score = 0
    socket.lock = false
    socket.createdAt = currentTimestamp
    socket.lastUpdate = currentTimestamp
    clients.push(socket)
    // console.log(clients)
  }

  if (socket.score != null) socket.emit("score", socket.score)

  socket.on("flag", async () => {
    db.get(
      "SELECT score FROM scores WHERE uuid = ?",
      [socket.uuid],
      function (err, row) {
        if (row.score >= MINIMUM_SCORE_FOR_FLAG) {
          socket.emit("flag", NETCOMP_FLAG)
        } else {
          socket.emit("flag", "LARI ADA KARBIT!")
        }
      }
    )
  })

  socket.on("init", async (data) => {
    socket.uuid = data.uuid
    socket.name = data.name
    socket.score = 0
  })

  socket.on("update", async (data) => {
    if (data.score > 0) {
      if (data.score > MAX_ALLOWED_SCORE_PER_TICK) {
        // do nothing
      } else {
        socket.score += data.score
      }

      if (socket.lock) {
        socket.emit("flag", "KARBIT DETECTED!")
        deleteData(socket)
      }
      socket.lock = true
    }

    let currentTimestamp = Date.now()
    console.log(socket.id, currentTimestamp, socket.lastUpdate, socket.lock)
    if (currentTimestamp - socket.lastUpdate > SERVER_TICK) {
      console.log("Unlocked")
      socket.lastUpdate = currentTimestamp
      socket.lock = false
    }
    if (currentTimestamp - socket.createdAt > 60000) {
      socket.disconnect()
    }
  })
})

function emitScore() {
  clients.forEach((client) => {
    if (client.score != null) client.emit("score", client.score)
  })
}

function loadScores() {
  setInterval(saveScores, 1000)
}

function saveScores() {
  clients.forEach((client) => {
    if (client.score != null) {
      db.run(
        "INSERT OR REPLACE INTO scores (uuid, name, score) VALUES (?, ?, ?)",
        [client.uuid, client.name, client.score],
        function (err) {
          if (err) {
            console.log(err)
          }
        }
      )
    }
  })
}

function purgeClients() {
  let currentTimestamp = Date.now()
  clients.forEach((client) => {
    if (currentTimestamp - client.createdAt > 60000) {
      client.disconnect()
    }
  })
  clients = clients.filter(
    (client) => currentTimestamp - client.createdAt <= 60000
  )
}

loadScores()
setInterval(emitScore, 1000)
setInterval(purgeClients, 1000)

http.listen(port, () => console.log(`App listening at port ${port}`))
